'''
Overview:
Add read depths from samtools depth results to a VCF table generated by
GATK VariantsToTable. This helps in determine whether a variant call
failed due to a lack of non-reference reads or poor coverage.

Usage:
Intended for use from a bash script or terminal. Flags may be given in
any order. If the specified output file already exists, will overwrite
the existing file.

python <path>/add_depth2vcf.v0.1.py \\
    tab=<input> \\
    depths=<input> \\
    tabout=<input> \\
    [dp_ext=.depth]

New in Version 0.2:
-Compatible only with output from coverage_slide.v0.1.py

:@param tab: (str) Path to variant table from VariantsToTable
:@param depths: (str) Path to dir with depth tables from samtools depth
:@param dp_ext: (str) File extension of depth tables; default .depth
:@param tabout: (str) Names output table; default ./my_vcf_depth.txt

'''

#Modules for data manipulation
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

#Modules for accessing files/directories on the system
import sys
import os
import glob

#Call input variables
tab = ''
depths = ''
depth_ext = '.depth'
tabout = './my_vcf_depth.txt'

#Record input from bash
for bashin in sys.argv:
    #Check for tab file input flag
    if bashin[:4] == 'tab=':
        tab = bashin[4:]
        #Check if tab input leads to a file
        assert( os.path.isfile(tab) ), \
            '{0} is not a file'.format(tab)
    #Check depth directory input flag
    elif bashin[:7] == 'depths=':
        depths = bashin[7:]
        #Check if tab input leads to a directory
        assert( os.path.isdir(depths) ), \
            '{0} is not a dir'.format(depths)
    #Check flag for name of the output table
    elif bashin[:7] == 'tabout=':
        tabout = bashin[7:]
    # Check flag for an alternate file extension
    elif bashin[:7] == 'dp_ext=':
        depth_ext = bashin[7:]
    else:
        #Skip anything without formatted flag
        print "{0} not used as variable\n".format(bashin)

#Replace VCF depth values from depth tables by CHROM, POS
def add_depth( vtable, dtable ):

    '''
    Main function for adding the depth values to the VCF table. Note
    that depth values from HaplotypeCaller in .DP columns will be
    replaced by depths from the alignments themselves. Will tally &
    report the number of time that this occurs.

    :@param vtable: (pd.DataFrame) VCF table from HaplotypeCaller
    :@param dtable: (pd.DataFrame) depth table from samtools depth
    :@param newcol: (str) Name new column for sample depth
    :@output: (pd.Series) Depth values to replace VCF table DPs
    '''
    #Change depth table columns to match VCF columns
    dtable.columns = ['CHROM', 'POS', 'COVERAGE', 'SLIDING']
    # Remove the plain coverage values
    dtable = dtable.drop("COVERAGE", axis=1)
    #Combine DataFrames by chr, position only on rows present in VCF
    newtable = pd.merge(
        vtable,
        dtable,
        how='left',
        on=['CHROM', 'POS']
        )
    #Check that the new dataframe is the correct size
    assert( newtable.shape[0] == vtable.shape[0] ), \
        "Original VCF table has {0} rows.".format(vtable.shape[0]) \
        + "Join of VCF table has {1} rows.".format(newtable.shape[0])
    return newtable['SLIDING']

#Load tab file as a pandas dataframe; saves correct headers
vcf_table = pd.read_table( tab, header=0, low_memory=False )

#Loop through depth tables in the depths directory
for depth_path in glob.iglob(depths + "/*" + depth_ext):
    #Get file name from the depth table path
    depth_file = depth_path.split( '/' )[-1:][0]
    #Get sample name from the file name
    sample = depth_file.split( '.' )[0]
    #Load depth table as a DataFrame
    depth_table = pd.read_table( depth_path, header=0 )
    #Check that the sample is in the VCF table
    assert( sample + '.DP' in vcf_table.columns ), \
        sample + ".DP not found in VCF table"
    #Add the depth info to the VCF table
    vcf_table[sample + ".DP"] = \
        add_depth( vcf_table, depth_table )
    #Report progress
    print "Added", sample

#Save new VCF DataFrame as a text file
vcf_table.to_csv( tabout, sep='\t')

#Report finished job
print "New table saved to", tabout
